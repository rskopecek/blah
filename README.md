# blah
An experiment in improving the development process

Reason for experiment:

Several aspects of development do not feel empowering.  Languanges come and go trying to improve on function and developer happiness.  As developers we are given a mighty magic wand to make amazing things and yet the outcomes are ever so frequently rot with design, readabilty, security, performance, etc problems.  Frequently the industry expectations are to address those issues with education and yet at the progressive rate of technology, no one can keep up.  While reading an application should be more like a wonderfully structured article/book, it's not uncommon for it to be a bit messy and a work in progress addressed through refactoring (if it ever happens).  Readability is often also limited by the languange semantics itself where often more popular or powerful languages adhere to a more geeky nature which can create barriers of understanding. Development requires the traits of a logician, an analyst, and a creative.  Yet without firm tools and knowledge of programming (the art of talking logical computer) a logician takes a long time to implement a logical structure.  Development feels so heavily focused on computers vs their logical constructs that the implementation of computer technology influences how development needs to occur instead of the other way around.

Reason for the name:

Sometimes when making a method, class, etc a junk name is used.  Naming is important and yet not.  Without a name, we often cannot progress to make that which it will be.  What something will be is far more important than the name it holds.  It's name constitutes a placeholder of potential meaning.  At some point people hope for a great name that sounds cool, is strong, conveys the intended meaning, and has not already be taken for other purposes. Naming is also cursed by irony.  Name something "awesome" or "ideal" and it will fall significantly short.   By that right, naming is hard.  Even if a name is absolute garbage according to the definition of a great name, yet it still provides value...it's done. So "blah", and time to make value.

Some Goals:

1. Purpose driven
2. Contextual driven
3. Restricted abilities based on purpose/context
4. Pattern driven
5. Clean and Readable
6. Immutable
7. Evolvable
8. Non/Less-constrained words (ex. Some Adapter instead of SomeAdapter or Some_Adapter)
9. Fluently and specifically expressive information
10. Macro & Meta, not implementation/compilation (ex. output is rendered to languange java, .net, javascript, etc)
11. Automated and manual testing/proving
12. Strict environment compliance (ex. 100% tested for production)
